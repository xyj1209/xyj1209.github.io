<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java集合]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java并发]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[整理在牛客网刷剑指offer的解题代码。 二维数组中的查找 时间限制：1s 空间：32768k 题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 public class Solution { public boolean Find(int target, int [][] array) { boolean hasTarget=false; for(int i=0;i&lt;array.length;i++){ for(int j=0;j&lt;array[i].length;j++){ if(array[i][j]==target){ hasTarget=true; break; } } } return hasTarget; } } 替换空格 时间限制：1s 空间：32768k 题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 public class Solution { public String replaceSpace(StringBuffer str) { StringBuffer newStr=new StringBuffer(); char[] base=str.toString().toCharArray(); for(int i=0;i&lt;base.length;i++){ if((base[i]+&quot;&quot;).equals(&quot; &quot;)){ newStr.append(&quot;%20&quot;); }else{ newStr.append(base[i]); } } return newStr.toString(); } } 从尾到头打印链表 时间限制：1s 空间：32768k 题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 /** * public class ListNode { * int val; * ListNode next = null; * * ListNode(int val) { * this.val = val; * } * } * */ import java.util.ArrayList; import java.util.Stack; public class Solution { public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) { Stack&lt;Integer&gt; stack=new Stack&lt;&gt;(); while(listNode!=null){ stack.push(listNode.val); listNode=listNode.next; } ArrayList&lt;Integer&gt; result=new ArrayList&lt;&gt;(); while(!stack.isEmpty()){ result.add(stack.pop()); } return result; } } 用两个栈实现队列 时间限制：1s 空间：32768k 题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 import java.util.Stack; /** *用一个栈作为基准，另一个作为辅助 *存在基准栈， *取，先把基准栈的元素存进辅助栈，再从辅助栈中弹出栈顶的元素为所求元素，再把剩余元素返回基准栈 **/ public class Solution { Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) { stack1.push(node); } public int pop() { while(!stack1.isEmpty()){ stack2.push(stack1.pop()); } int result= stack2.pop(); while(!stack2.isEmpty()){ stack1.push(stack2.pop()); } return result; } } 旋转数组的最小数字 时间限制：3秒 空间限制：32768K 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 import java.util.ArrayList; public class Solution { public int minNumberInRotateArray(int [] array) { int min=array[0]; if(array.length==0){ return 0; } for(int i=0;i&lt;array.length;i++){ if(array[i]&lt;min){ min=array[i]; } } return min; } } 斐波那契数列 时间限制：1秒 空间限制：32768K 题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 public class Solution { public int Fibonacci(int n) { int a=1;//n-2 int b=1;//n-1 int c=a+b;//n if(n==0){ return 0; }else if(n&lt;3){ return 1; }else{ for(int i=3;i&lt;=n;i++){ c=a+b;//计算n //n-1、n-2递进 a=b; b=c; } return c; } } } 矩阵覆盖 时间限制：1秒 空间限制：32768K 题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ public class Solution { /** *这题考的也是斐波那契数列 **/ public int RectCover(int target) { int a=1;//n-2 int b=2;//n-1 int c=a+b;//n if(target==0){ return 0; }else if(target==1){ return 1; }else if(target==2){ return 2; }else{ for(int i=3;i&lt;=target;i++){ c=a+b; a=b; b=c; } return c; } } } 二进制中1的个数 时间限制：1秒 空间限制：32768K 题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 public class Solution { public int NumberOf1(int n) { return Integer.bitCount(n); } } 数值的整数次方 时间限制：1秒 空间限制：32768K 题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 public class Solution { public double Power(double base, int exponent) { return Math.pow(base,exponent); } } 调整数组顺序使奇数位于偶数前面 时间限制：1秒 空间限制：32768K 题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 public class Solution { public void reOrderArray(int [] array) { int[] result=new int[array.length]; int index=0; for(int i=0;i&lt;array.length;i++){ if(array[i]%2!=0){ result[index++]=array[i]; } } for(int i=0;i&lt;array.length;i++){ if(array[i]%2==0){ result[index++]=array[i]; } } for(int i=0;i&lt;result.length;i++){ array[i]=result[i]; } } } 链表中倒数第k个结点 时间限制：1秒 空间限制：32768K 题目描述输入一个链表，输出该链表中倒数第k个结点。 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ import java.util.Stack; public class Solution { public ListNode FindKthToTail(ListNode head,int k) { if(head==null){ return null; } Stack&lt;ListNode&gt; stack=new Stack&lt;&gt;(); int size=0; while(head!=null){ stack.push(head); head=head.next; size++; } if(size&lt;k||k&lt;=0){ return null; } int index=1; while(index&lt;k){ stack.pop(); index++; } return stack.pop(); } } 顺时针打印矩阵 时间限制：1秒 空间限制：32768K 题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. import java.util.ArrayList; public class Solution { public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) { ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); int up = 0; int left = 0; int down = matrix.length - 1; int right = matrix[0].length - 1; while(left&lt;=right &amp;&amp; up&lt;=down){ for(int i = left ; i &lt;= right ; i++) arr.add(matrix[up][i]); up++; for(int i = up ; i &lt;= down ; i++) arr.add(matrix[i][right]); right--; if(up-1 != down){ for(int i = right ; i &gt;= left ; i--) arr.add(matrix[down][i]); } down--; if(left != right+1){ for(int i = down ; i &gt;= up ; i--) arr.add(matrix[i][left]); } left++; } return arr; } } 包含min函数的栈 时间限制：1秒 空间限制：32768K 题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 import java.util.Stack; public class Solution { private int min=Integer.MAX_VALUE; private Stack&lt;Integer&gt; stack=new Stack&lt;&gt;(); private Stack&lt;Integer&gt; minStack=new Stack&lt;&gt;();//存最小 private int top=0; public void push(int node) { if(min&gt;node){ min=node; } minStack.push(min); stack.push(node); } public void pop() { if(!stack.isEmpty()){ stack.pop(); minStack.pop(); min=minStack.pop(); minStack.push(min); } } public int top() { return stack.peek(); } public int min() { return min; } } 数组中出现次数超过一半的数字 时间限制：1秒 空间限制：32768K 题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 import java.util.Arrays; public class Solution { public int MoreThanHalfNum_Solution(int [] array) { if(array.length==1)return array[0]; Arrays.sort(array); for(int i=0;i&lt;array.length/2;i++){ if(array[i]==array[i+array.length/2]){ return array[i]; } } return 0; } } 最小的K个数 时间限制：1秒 空间限制：32768K 题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 import java.util.Arrays; import java.util.ArrayList; public class Solution { public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) { Arrays.sort(input); ArrayList&lt;Integer&gt; result=new ArrayList&lt;Integer&gt;(); if(k&lt;=0||k&gt;input.length)return result; for(int i=0;i&lt;k;i++){ result.add(input[i]); } return result; } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机]]></title>
    <url>%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[运行时数据区域 程序计数器（Program Counter Register）线程私有当前线程的执行指令的指向（虚拟机字节码指令的地址） Java虚拟机栈（VM Stack）线程私有每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等，局部变量表存放编译器可知的各种基本数据类型、对象引用、代表对象的句柄或其它与此对象相关的位置、returnAddress类型。其中double、long会占用两个局部变量的空间（Slot）。 有关这个区域的两种异常状况 1. StackOverflowError这个错误指的是栈的层数超出了虚拟机允许的层数 示例代码： @Test public void testStackOverflowError() { testStackOverflowError(); } 2. OutOfMemoryError这个错误指的是扩展内容超出了虚拟机分配的内存，无法请求得到 示例代码： @Test public void testOutOfMemoryError() { while(true) { new ArrayList&lt;String&gt;(1000000000); } } 本地方法栈（Native Method Stack）线程私有本地方法栈和虚拟机栈的作用差不多，服务对象是本地方法，而虚拟机栈是服务Java方法。其它方面和虚拟机栈差不多。 Sun Hot Spot 把两者合为一体。 Java堆（Heap）（GC堆）线程共享Java堆是线程共享的内存，在虚拟机启动的时候创建，唯一目的是存放对象实例。几乎所有的对象都是在Java堆上进行分配。 注：栈上分配、标量替换优化技术使得堆上分配技术变得不那么绝对。 Java堆可细分为新生代和老年代。新生代又可划分出Eden、From Survivor、To Survivor。还可划分为多个线程私有的分配缓冲区（TLAB），目的是为了防止多线程并发请求分配同一段内存冲突的情况发生。Java堆是逻辑上连续的内存空间，物理上不一定会连续。 通过 -Xms 可以设置堆的初始大小通过 -Xmx 可以设置堆的最大大小当堆上没有足够内存空间分配给对象或者没有空间进行扩展的时候，会抛出OutOfMemoryError 方法区（Method Area）线程共享用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 HotSpot 把它划分为永久代，或者说用永久代来实现方法区 内存回收主要是常量池回收和类型卸载 运行时常量池属于方法区的一部分，存放编译器生成的各种符号引用和字面量。 常量不一定只在编译器时产生，如String.intern()可以在运行时动态产生常量。 附加知识点直接内存不是虚拟机运行时区域的一部分，但是有一些关系，这里也来扯一下。通过使用Native函数直接分配堆外内存。本机直接内存不会受Java堆的限制，但会受本机内存的限制如RAM、Swap以及分页文件。 优点：可以显著提升性能，避免在Java堆和Native堆来回复制数据。 垃圾收集器与内存分配策略垃圾回收算法 简略介绍几种垃圾回收算法 标记-清除算法标记-清除算法指的是对需要进行回收的内存段进行标记，再进行清除。 缺点： 空间问题：会产生大量不连续的碎片化的内存。 时间问题：标记和清除的效率都不高。 标记-整理算法标记-整理算法相对于标记-清除算法的改进在于回收内存后剩余的存活对象是连续的，空间效率变高了。 主要实现是让存活的对象向一端靠拢，再清除另一端被标记的内存对象。 以上两种算法多用于老年代的内存回收，由老年代内存对象大部分不被清理的特征决定了。 复制算法复制算法多用于新生代，把内存划分为Eden(80%)、From Survivor(10%)、To Survivor(10%),回收的过程是把Eden和一个Survivor区的存活对象复制到另一个Survivor,所以浪费的内存空间有10%。 复制算法用于新生代,由98%（不绝对）的新生代对象都会被回收的特征决定的。由于不能保证每次回收剩余的内存对象会少于10%,所以需要分配担保。所有超出10%的对象都会直接进入老年代。 判断对象是否存活的算法引用计数算法引用计数算法是给对象添加一个引用计数器，有引用，计数器加一，引用失效，计数器减一。引用计数器算法的效率很高，也很简单。但是，虚拟机并不采用这种方法。由以下代码可以说明： public class Main { public Object instance=null; public static void main(String[] args) { Main m1=new Main();//m1:0+1 Main m2=new Main(); m1.instance=m2;//m1:1+1 m2.instance=m1; m1=null;//m1:2-1 m2=null; System.gc(); } } 可达性分析算法可达性分析算法是判断对象到GC Roots有没有引用链，没有就被回收。 GC Roots： 虚拟机栈（栈帧的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI(即一般说的Native方法)引用的对象。 引用分类 强引用 永远不会清除强引用的对象，如Object o=new Object()这类引用。 软引用 还有用但并非必需的对象。在发生内存溢出异常之前，会将这些对象列进入回收范围内进行第二次回收。使用SoftReference类来实现软引用。 Object object = new Object(); SoftReference&lt;Object&gt; sReference = new SoftReference&lt;Object&gt;(object); object = null; 弱引用 非必需的对象。只能生存到下一次垃圾收集之前。使用WeakReference类来实现弱引用。 Object object = new Object(); WeakReference&lt;Object&gt; wReference = new WeakReference&lt;Object&gt;(object); object = null; 虚引用 又称幽灵引用或者幻影引用，最弱的一种引用。不会对其生存时间构成影响。只能在被回收的时候收到一个系统的通知。使用PhantomReference类来实现虚引用。 Object object = new Object(); PhantomReference&lt;Object&gt; pReference = new PhantomReference&lt;Object&gt;(object); object = null; 垃圾回收器的介绍Serial收集器是一个最基本、历史悠久的收集器，单线程，会暂停其它所有线程，直到垃圾回收完成（Stop the World!） 对于运行在Client下的虚拟机来说是很好的选择，简单而高效，没有线程交互产生的开销。 ParNew收集器是Serial的多线程版本，大部分实现代码是一样的。 以上两种新生代收集器是唯一能够和CMS配合使用的收集器均使用复制算法。 Serial Old(MSC)收集器Serial的老年代版收集器，使用标记-整理算法。 可以搭配Parallel Scavenge使用，或者作为CMS失败的后备方案 Parallel Old 收集器Parallel的老年代版收集器，使用标记-整理算法。 注重CPU资源敏感和吞吐量的场合可以考虑Parallel Old 结合Parallel Scavenge。 Parallel Scavenge收集器（吞吐量优先）是一个新生代收集器，主要关注点在吞吐量（既运行代码时间/（运行代码时间+垃圾收集时间）） 例如：虚拟机总运行100分钟，垃圾回收需要花费10分钟，那么吞吐量就是90%适合不需要交互的后台任务与ParNew的区别在于它可以使用GC自适应的调节策略，通过输入参数 -XX:UseAdaptiveSizePolicy 虚拟机会根据当前系统运行的情况收集性能监控，自动调节新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等参数。 CMS（Concurrent Mark Sweep）收集器是以最短回收时间为目标的老年代收集器。算法使用标记-清除算法，会产生内存碎片。回收分为几个过程： 初始标记(标记GC Roots 能直接关联的对象)。 并发标记(进行GC Roots Tracing)。 重新标记(修正并发标记期间因用户程序操作而产生变动的那部分对象的标记记录)。 并发清除。 注：初始标记和重新标记会Stop the World，并发标记和并发清除不会停顿。 缺点： 对CPU资源敏感，吞吐量不高。 无法处理‘浮动垃圾’，可能出现‘Concurrent Mode Failure’,从而导致另一次的Full GC产生。 使用标记-清除算法会产生大量内存碎片。G1(Garbage-First)收集器 相对于之前几个收集器，有很大的区别 不仅仅对于新生代或者老年代一个对象，而是把内存划分为Region,可以单独管理内存。 全局使用标记-整理，局部(Region之间)使用复制。 清理可预测性，通过跟踪每个Region内垃圾堆积的经验价值，在后台构建一个列表，每次垃圾回收，清理价值高的内存，以提高清理效率。 运作步骤： 初始标记(标记GC Roots 能直接关联的对象)。 并发标记(进行GC Roots Tracing)。 最终标记(修正并发标记期间因用户程序操作而产生变动的那部分对象的标记记录)。 筛选回收(对回收对象进行排序，在有限的条件下尽可能回收更多的内存对象) 内存分配与回收策略内存分配 对象优先在Eden分配 当Eden无法存放对象的时候，会触发Minor GC,发生GC的时候，如果存活的对象在Survivor中没有空间进行存储，超出的部分会直接通过担保机制进入老年代。 大对象直接进入老年代 大对象指的是需要连续空间的对象，如长字符串、byte[]数组等。 长期存活的对象将进入老年代 默认老年代的年龄是15，但是，有些对象也不必到15就能进入老年代。如果在Survivor中相同年龄的对象大于总空间的一半，那么大于这个年龄的所有对象将进入老年代。 类加载机制类加载的生命周期： 加载、验证、准备、解析、初始化、使用、卸载.加载、验证、准备、初始化、卸载这五个阶段的顺序是一定的。 类加载过程加载&gt; 在加载阶段，虚拟机要完成三件事情 1. 通过一个类的全限定名来获取定义此类的二进制字节流。 2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 验证 验证是连接阶段的第一步，这个阶段的目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证分四个阶段 文件格式验证（对象：字节流） 是否以魔数OxCAFEBABE开头 主次版本是否在当前虚拟机处理的范围 常量池中的常量中是否有不被支持的常量类型（检查常量的tag标志） 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。 Class文件中各部分及文件本身是否有被删除的或附加的其它信息。 …… 验证完后，字节流才会进入内存的方法区中进行存储。 元数据验证（对象：方法区的存储结构） 这个类是否有父类。 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现了不符合规则的方法的重载，例如方法参数都一致，但返回值类型不一致等） …… 这个阶段主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规定的元数据信息。 字节码验证（对象：方法区的存储结构） 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈中放置了一个int类型的数据，使用时却按long类型来载入本地变量表。 保证跳转指令不会跳转到方法体以外的字节码指令上。 保证方法体的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是吧父类对象赋值给子类数据类型，甚至给与它毫无继承关系，完成无相关的一个数据类型，则是不安全的。 …… 这个阶段主要目的是对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 符号引用验证（对象：方法区的存储结构） 符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验 符号引用中通过字符串描述的全限定名是否能找到相应的类。 在指定的类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。 符合引用中的类、字段、方法的访问性（private、protected、public、default）是否可以被当前类访问。 …… 准备准备阶段是正式为类变量（被static修饰的变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区进行分配。 例如：public static int value=110;在方法区对value进行内存分配，并设置初始值为0，而不是110。public static final int value=110;在方法区对value进行内存分配，并设置初始值为110，而不是0。因为类字段的字段属性表中存在ConstantValue属性。 解析将常量池中的符合引用转化为直接引用。 符号引用和直接引用的定义 符号引用以一组符号来描述目标，引用的目标不一定已经加载到内存中，各种虚拟机接受符号引用必须得一致，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 直接引用一定加载到内存中，因为它与内存是有关系的，直接引用直接指向目标的指针、相对偏移量、句柄等。 初始化初始化是类加载的最后一步，是真正执行类中定义的Java执行代码，执行类构造器&lt;clinit&gt;()方法的过程。 初始化的5种情况 遇到new、getstatic、setstatic、invokestatic,对应的意思是使用new关键字实例化对象、读取或设置类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法的时候。 使用java.lang.reflect类中的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动的时候，用户需要指定一个要执行的主类的时候，虚拟机会先初始化这个主类。 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 &lt;clinit&gt;()方法如何产生 由编译器自动收集所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生。在前面的静态语句块可以赋值，但不能访问后面的变量。 public class Test { static { i=110;//可以给后面的变量赋值 System.out.println(i);//报错，不能访问后面的变量 } static int i=0; } 会先执行父类的&lt;clinit&gt;()方法，不用显示调用。所以虚拟机第一个加载&lt;clinit&gt;()方法是java.lang.Object类的。 由于会先执行父类的 &lt;clinit&gt;()方法，所以父类的静态块会优先于子类的。 class Test{ static class ParentTest { public static int i=0; static { i=110; } } static class SubTest extends ParentTest { public static int j=i; } public static void main(String[] args) { System.out.println(SubTest.j); } } 会输出110，因为父类的静态块会优先加载，i不是0而是110了，再赋值给j,j就变成110。 没有静态语句块的类，不会产生&lt;clinit&gt;()方法。 执行接口&lt;clinit&gt;()方法不会先执行父接口的&lt;clinit&gt;()方法，这点和类不一样，父接口的变量被使用时才会执行&lt;clinit&gt;()方法，接口的实现类在初始化的时候也不会执行这个接口的&lt;clinit&gt;()方法。 并发执行一个类的&lt;clinit&gt;()方法时，会进行堵塞操作，保证被正确的加锁、同步。 类加载器Boostrap ClassLoader启动类加载器，负责将%JAVA_HOME%/lib目录或被-Xbootclasspath参数所指定的路径的类（并且是虚拟机识别的）加载到内存。 Extension ClassLoader扩展类加载器，负责加载%JAVA_HOME%/lib/ext下或者被java.ext.dirs系统变量所指定的路径下的类到内存。 Application ClassLoader应用程序类加载器，也叫系统类加载器，负责加载用户路径（ClassPath）上指定的类库。 双亲委托机制双亲委托机制很好理解，如果一个类加载器收到类加载的请求，会把这个请求委派给父类加载器去完成，父类又委派给父类加载器，最后第一个加载器都是最顶端的启动类加载器先加载，保证了本身的安全性。]]></content>
  </entry>
</search>
