<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><hr><h3 id="程序计数器（Program-Counter-Register）线程私有"><a href="#程序计数器（Program-Counter-Register）线程私有" class="headerlink" title="程序计数器（Program Counter Register）线程私有"></a>程序计数器（Program Counter Register）线程私有</h3><p>当前线程的执行指令的指向（虚拟机字节码指令的地址） </p><h3 id="Java虚拟机栈（VM-Stack）线程私有"><a href="#Java虚拟机栈（VM-Stack）线程私有" class="headerlink" title="Java虚拟机栈（VM Stack）线程私有"></a>Java虚拟机栈（VM Stack）线程私有</h3><p>每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等，局部变量表存放编译器可知的各种基本数据类型、对象引用、代表对象的句柄或其它与此对象相关的位置、returnAddress类型。其中double、long会占用两个局部变量的空间（Slot）。  </p><blockquote><p>有关这个区域的两种异常状况</p></blockquote><h4 id="1-StackOverflowError"><a href="#1-StackOverflowError" class="headerlink" title="1. StackOverflowError"></a>1. StackOverflowError</h4><p>这个错误指的是栈的层数超出了虚拟机允许的层数  </p><blockquote><p>示例代码：</p></blockquote><pre><code>@Test public void testStackOverflowError() {      testStackOverflowError();  }</code></pre><h4 id="2-OutOfMemoryError"><a href="#2-OutOfMemoryError" class="headerlink" title="2. OutOfMemoryError"></a>2. OutOfMemoryError</h4><p>这个错误指的是扩展内容超出了虚拟机分配的内存，无法请求得到  </p><blockquote><p>示例代码：</p></blockquote><pre><code>@Test  public void testOutOfMemoryError() {      while(true) {          new ArrayList&lt;String&gt;(1000000000);      }  }</code></pre><h3 id="本地方法栈（Native-Method-Stack）线程私有"><a href="#本地方法栈（Native-Method-Stack）线程私有" class="headerlink" title="本地方法栈（Native Method Stack）线程私有"></a>本地方法栈（Native Method Stack）线程私有</h3><p>本地方法栈和虚拟机栈的作用差不多，服务对象是本地方法，而虚拟机栈是服务Java方法。其它方面和虚拟机栈差不多。</p><blockquote><p>Sun Hot Spot 把两者合为一体。</p></blockquote><h3 id="Java堆（Heap）（GC堆）线程共享"><a href="#Java堆（Heap）（GC堆）线程共享" class="headerlink" title="Java堆（Heap）（GC堆）线程共享"></a>Java堆（Heap）（GC堆）线程共享</h3><p>Java堆是线程共享的内存，在虚拟机启动的时候创建，唯一目的是存放对象实例。几乎所有的对象都是在Java堆上进行分配。</p><blockquote><p>注：栈上分配、标量替换优化技术使得堆上分配技术变得不那么绝对。</p></blockquote><p>Java堆可细分为<strong>新生代</strong>和<strong>老年代</strong>。<br>新生代又可划分出<strong>Eden、From Survivor、To Survivor</strong>。<br>还可划分为<strong>多个线程私有的分配缓冲区（TLAB）</strong>，目的是为了防止多线程并发请求分配同一段内存冲突的情况发生。<br>Java堆是逻辑上连续的内存空间，物理上不一定会连续。</p><blockquote><p>通过 <strong>-Xms</strong> 可以设置堆的初始大小<br>通过 <strong>-Xmx</strong> 可以设置堆的最大大小<br>当堆上没有足够内存空间分配给对象或者没有空间进行扩展的时候，会抛出<strong>OutOfMemoryError</strong></p></blockquote><h3 id="方法区（Method-Area）线程共享"><a href="#方法区（Method-Area）线程共享" class="headerlink" title="方法区（Method Area）线程共享"></a>方法区（Method Area）线程共享</h3><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><blockquote><p>HotSpot 把它划分为永久代，或者说用永久代来实现方法区</p></blockquote><blockquote><p>内存回收主要是常量池回收和类型卸载</p></blockquote><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>属于方法区的一部分，存放编译器生成的各种符号引用和字面量。</p><blockquote><p>常量不一定只在编译器时产生，如String.intern()可以在运行时动态产生常量。</p></blockquote><h3 id="附加知识点"><a href="#附加知识点" class="headerlink" title="附加知识点"></a>附加知识点</h3><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>不是虚拟机运行时区域的一部分，但是有一些关系，这里也来扯一下。通过使用Native函数直接分配堆外内存。本机直接内存不会受Java堆的限制，但会受本机内存的限制如RAM、Swap以及分页文件。</p><blockquote><p>优点：可以显著提升性能，避免在Java堆和Native堆来回复制数据。</p></blockquote><hr><h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><blockquote><p>简略介绍几种垃圾回收算法</p></blockquote><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记-清除算法指的是对需要进行回收的内存段进行标记，再进行清除。</p><blockquote><p>缺点：</p><ol><li>空间问题：会产生大量不连续的碎片化的内存。</li><li>时间问题：标记和清除的效率都不高。</li></ol></blockquote><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-整理算法相对于标记-清除算法的改进在于回收内存后剩余的存活对象是连续的，空间效率变高了。</p><blockquote><p>主要实现是让存活的对象向一端靠拢，再清除另一端被标记的内存对象。</p></blockquote><p><strong><em>以上两种算法多用于老年代的内存回收，由老年代内存对象大部分不被清理的特征决定了。</em></strong></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法多用于新生代，把内存划分为Eden(80%)、From Survivor(10%)、To Survivor(10%),回收的过程是把Eden和一个Survivor区的存活对象复制到另一个Survivor,所以浪费的内存空间有10%。</p><blockquote><p>复制算法用于新生代,由98%（不绝对）的新生代对象都会被回收的特征决定的。<br>由于不能保证每次回收剩余的内存对象会少于10%,所以需要分配担保。所有超出10%的对象都会直接进入老年代。</p></blockquote><h3 id="判断对象是否存活的算法"><a href="#判断对象是否存活的算法" class="headerlink" title="判断对象是否存活的算法"></a>判断对象是否存活的算法</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法是给对象添加一个引用计数器，有引用，计数器加一，引用失效，计数器减一。<br>引用计数器算法的效率很高，也很简单。但是，虚拟机并不采用这种方法。<br>由以下代码可以说明：</p><pre><code>public class Main {    public Object instance=null;    public static void main(String[] args) {        Main m1=new Main();//m1:0+1        Main m2=new Main();        m1.instance=m2;//m1:1+1        m2.instance=m1;        m1=null;//m1:2-1        m2=null;        System.gc();    }}</code></pre><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析算法是判断对象到GC Roots有没有引用链，没有就被回收。</p><blockquote><p>GC Roots：</p><ul><li>虚拟机栈（栈帧的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象。</li></ul></blockquote><blockquote><p>引用分类</p><ul><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li></ul></blockquote><h3 id="垃圾回收器的介绍"><a href="#垃圾回收器的介绍" class="headerlink" title="垃圾回收器的介绍"></a>垃圾回收器的介绍</h3><ul><li><p>Serial收集器</p><p>  是一个最基本、历史悠久的收集器，单线程，会暂停其它所有线程，直到垃圾回收完成（Stop the World!）</p><blockquote><p>对于运行在Client下的虚拟机来说是很好的选择，简单而高效，没有线程交互产生的开销。</p></blockquote></li><li><p>ParNew收集器</p><p>  是Serial的多线程版本，大部分实现代码是一样的。</p><blockquote><p>以上两种新生代收集器是唯一能够和CMS配合使用的收集器<br>均使用复制算法。</p></blockquote></li><li><p>Serial Old(MSC)收集器<br>  Serial的老年代版收集器，使用标记-整理算法。</p><blockquote><p>可以搭配Parallel Scavenge使用，或者作为CMS失败的后备方案</p></blockquote></li><li><p>Parallel Old 收集器<br>  Parallel的老年代版收集器，使用标记-整理算法。</p><blockquote><p>注重CPU资源敏感和吞吐量的场合可以考虑Parallel Old 结合Parallel Scavenge。</p></blockquote></li><li><p>Parallel Scavenge收集器（吞吐量优先）</p><p>  是一个新生代收集器，主要关注点在吞吐量（既运行代码时间/（运行代码时间+垃圾收集时间））</p><blockquote><p>例如：虚拟机总运行100分钟，垃圾回收需要花费10分钟，那么吞吐量就是90%<br>适合不需要交互的后台任务<br>与ParNew的区别在于它可以使用GC自适应的调节策略，通过输入参数 <strong>-XX:UseAdaptiveSizePolicy</strong> 虚拟机会根据当前系统运行的情况收集性能监控，自动调节新生代的大小（<strong>-Xmn</strong>）、Eden与Survivor区的比例（<strong>-XX:SurvivorRatio</strong>）、晋升老年代对象大小（<strong>-XX:PretenureSizeThreshold</strong>）等参数。</p></blockquote></li><li><p>CMS（Concurrent Mark Sweep）收集器</p><p>  是以最短回收时间为目标的老年代收集器。<br>  算法使用标记-清除算法，会产生内存碎片。<br>  回收分为几个过程：</p><ol><li>初始标记(标记GC Roots 能直接关联的对象)。</li><li>并发标记(进行GC Roots Tracing)。</li><li>重新标记(修正并发标记期间因用户程序操作而产生变动的那部分对象的标记记录)。</li><li><p>并发清除。</p><blockquote><p>注：初始标记和重新标记会Stop the World，并发标记和并发清除不会停顿。</p></blockquote><p>缺点：</p></li></ol><ul><li>对CPU资源敏感，吞吐量不高。</li><li>无法处理‘浮动垃圾’，可能出现‘Concurrent Mode Failure’,从而导致另一次的Full GC产生。</li><li>使用标记-清除算法会产生大量内存碎片。</li></ul></li><li><p>G1(Garbage-First)收集器<br>  相对于之前几个收集器，有很大的区别</p><ol><li>不仅仅对于新生代或者老年代一个对象，而是把内存划分为Region,可以单独管理内存。</li><li>全局使用标记-整理，局部(Region之间)使用复制。</li><li><p>清理可预测性，通过跟踪每个Region内垃圾堆积的经验价值，在后台构建一个列表，每次垃圾回收，清理价值高的内存，以提高清理效率。</p><p>运作步骤：</p></li><li>初始标记(标记GC Roots 能直接关联的对象)。</li><li>并发标记(进行GC Roots Tracing)。</li><li>最终标记(修正并发标记期间因用户程序操作而产生变动的那部分对象的标记记录)。</li><li>筛选回收(对回收对象进行排序，在有限的条件下尽可能回收更多的内存对象)<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3></li></ol></li><li><p>内存分配</p><ol><li>对象优先在Eden分配<br> 当Eden无法存放对象的时候，会触发Minor GC,发生GC的时候，如果存活的对象在Survivor中没有空间进行存储，超出的部分会直接通过担保机制进入老年代。</li><li>大对象直接进入老年代<br> 大对象指的是需要连续空间的对象，如长字符串、byte[]数组等。</li><li>长期存活的对象将进入老年代<br> 默认老年代的年龄是15，但是，有些对象也不必到15就能进入老年代。如果在Survivor中相同年龄的对象大于总空间的一半，那么大于这个年龄的所有对象将进入老年代。</li></ol></li></ul><hr><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类加载的生命周期： 加载、验证、准备、解析、初始化、使用、卸载.<br>加载、验证、准备、初始化、卸载这五个阶段的顺序是一定的。</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ul><li><p>加载</p><blockquote><p>在加载阶段，虚拟机要完成三件事情</p></blockquote><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol></li><li><p>验证</p><blockquote><p>验证是连接阶段的第一步，这个阶段的目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>验证分四个阶段</p></blockquote><ol><li><p>文件格式验证（对象：字节流）</p><ul><li>是否以魔数OxCAFEBABE开头</li><li>主次版本是否在当前虚拟机处理的范围</li><li>常量池中的常量中是否有不被支持的常量类型（检查常量的tag标志）</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。</li><li>Class文件中各部分及文件本身是否有被删除的或附加的其它信息。</li><li><p>……</p><p>验证完后，字节流才会进入内存的方法区中进行存储。</p></li></ul></li><li><p>元数据验证（对象：方法区的存储结构）</p><ul><li>这个类是否有父类。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现了不符合规则的方法的重载，例如方法参数都一致，但返回值类型不一致等）</li><li><p>……</p><p>这个阶段主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规定的元数据信息。</p></li></ul></li><li><p>字节码验证（对象：方法区的存储结构）</p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈中放置了一个int类型的数据，使用时却按long类型来载入本地变量表。</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li><li>保证方法体的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是吧父类对象赋值给子类数据类型，甚至给与它毫无继承关系，完成无相关的一个数据类型，则是不安全的。</li><li><p>……</p><p>这个阶段主要目的是对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</p></li></ul></li><li>符号引用验证（对象：方法区的存储结构）<br> 符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验<ul><li>符号引用中通过字符串描述的全限定名是否能找到相应的类。</li><li>在指定的类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li><li>符合引用中的类、字段、方法的访问性（private、protected、public、default）是否可以被当前类访问。</li><li>……</li></ul></li></ol></li><li><p>准备<br>  准备阶段是正式为类变量（被static修饰的变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区进行分配。</p><blockquote><p>例如：</p><pre><code>public static int value=110;在方法区对value进行内存分配，并设置初始值为0，而不是110。public static **final** int value=110;在方法区对value进行内存分配，并设置初始值为110，而不是0。因为类字段的字段属性表中存在ConstantValue属性。</code></pre></blockquote></li><li><p>解析<br>  将常量池中的符合引用转化为直接引用。</p><blockquote><p>符号引用和直接引用的定义</p></blockquote><ul><li><p>符号引用以一组符号来描述目标，引用的目标不一定已经加载到内存中，各种虚拟机接受符号引用必须得一致，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p></li><li><p>直接引用一定加载到内存中，因为它与内存是有关系的，直接引用直接指向目标的指针、相对偏移量、句柄等。</p></li></ul></li><li><p>初始化</p><blockquote><p>初始化的5种情况</p></blockquote><ol><li>遇到new、getstatic、setstatic、invokestatic,对应的意思是使用new关键字实例化对象、读取或设置类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法的时候。 </li><li>使用java.lang.reflect类中的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动的时候，用户需要指定一个要执行的主类的时候，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ol></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="Boostrap-ClassLoader"><a href="#Boostrap-ClassLoader" class="headerlink" title="Boostrap ClassLoader"></a>Boostrap ClassLoader</h4><h4 id="Extension-ClassLoader"><a href="#Extension-ClassLoader" class="headerlink" title="Extension ClassLoader"></a>Extension ClassLoader</h4><h4 id="Application-ClassLoader"><a href="#Application-ClassLoader" class="headerlink" title="Application ClassLoader"></a>Application ClassLoader</h4><h3 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h3>]]></content>
      
      
      
    </entry>
    
  
  
</search>
