<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java虚拟机]]></title>
    <url>%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[运行时数据区域 程序计数器（Program Counter Register）线程私有当前线程的执行指令的指向（虚拟机字节码指令的地址） Java虚拟机栈（VM Stack）线程私有每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等，局部变量表存放编译器可知的各种基本数据类型、对象引用、代表对象的句柄或其它与此对象相关的位置、returnAddress类型。其中double、long会占用两个局部变量的空间（Slot）。 有关这个区域的两种异常状况 1. StackOverflowError这个错误指的是栈的层数超出了虚拟机允许的层数 示例代码： @Test public void testStackOverflowError() { testStackOverflowError(); } 2. OotOfMemoryError这个错误指的是扩展内容超出了虚拟机分配的内存，无法请求得到 示例代码： @Test public void testOutOfMemoryError() { while(true) { new ArrayList&lt;String&gt;(1000000000); } } 本地方法栈（Native Method Stack）线程私有本地方法栈和虚拟机栈的作用差不多，服务对象是本地方法，而虚拟机栈是服务Java方法。其它方面和虚拟机栈差不多。 Sun Hot Spot 把两者合为一体。 Java堆（Heap）（GC堆）线程共享Java堆是线程共享的内存，在虚拟机启动的时候创建，唯一目的是存放对象实例。几乎所有的对象都是在Java堆上进行分配。 注：栈上分配、标量替换优化技术使得堆上分配技术变得不那么绝对。 Java堆可细分为新生代和老年代。新生代又可划分出Eden、From Survivor、To Survivor。还可划分为多个线程私有的分配缓冲区（TLAB），目的是为了防止多线程并发请求分配同一段内存冲突的情况发生。Java堆是逻辑上连续的内存空间，物理上不一定会连续。 通过 -Xms 可以设置堆的初始大小通过 -Xmx 可以设置堆的最大大小当堆上没有足够内存空间分配给对象或者没有空间进行扩展的时候，会抛出OutOfMemoryError 方法区（Method Area）线程共享用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 HotSpot 把它划分为永久代，或者说用永久代来实现方法区 内存回收主要是常量池回收和类型卸载 运行时常量池属于方法区的一部分，存放编译器生成的各种符号引用和字面量。 常量不一定只在编译器时产生，如String.intern()可以在运行时动态产生常量。 附加知识点直接内存不是虚拟机运行时区域的一部分，但是有一些关系，这里也来扯一下。通过使用Native函数直接分配堆外内存。本机直接内存不会受Java堆的限制，但会受本机内存的限制如RAM、Swap以及分页文件。 优点：可以显著提升性能，避免在Java堆和Native堆来回复制数据。 垃圾收集器与内存分配策略垃圾回收算法 简略介绍几种垃圾回收算法 标记-清除算法标记-清除算法指的是对需要进行回收的内存段进行标记，再进行清除。 缺点： 空间问题：会产生大量不连续的碎片化的内存。 时间问题：标记和清除的效率都不高。 标记-整理算法标记-整理算法相对于标记-清除算法的改进在于回收内存后剩余的存活对象是连续的，空间效率变高了。 主要实现是让存活的对象向一端靠拢，再清除另一端被标记的内存对象。 以上两种算法多用于老年代的内存回收，由老年代内存对象大部分不被清理的特征决定了。 复制算法复制算法多用于新生代，把内存划分为Eden(80%)、From Survivor(10%)、To Survivor(10%),回收的过程是把Eden和一个Survivor区的存活对象复制到另一个Survivor,所以浪费的内存空间有10%。 复制算法用于新生代,由98%（不绝对）的新生代对象都会被回收的特征决定的。由于不能保证每次回收剩余的内存对象会少于10%,所以需要分配担保。所有超出10%的对象都会直接进入老年代。 判断对象是否存活的算法引用计数算法引用计数算法是给对象添加一个引用计数器，有引用，计数器加一，引用失效，计数器减一。引用计数器算法的效率很高，也很简单。但是，虚拟机并不采用这种方法。由以下代码可以说明： public class Main { public Object instance=null; public static void main(String[] args) { Main m1=new Main();//m1:0+1 Main m2=new Main(); m1.instance=m2;//m1:1+1 m2.instance=m1; m1=null;//m1:2-1 m2=null; System.gc(); } } 可达性分析算法可达性分析算法是判断对象到GC Roots有没有引用链，没有就被回收。 GC Roots： 虚拟机栈（栈帧的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI(即一般说的Native方法)引用的对象。 引用分类 强引用 软引用 弱引用 虚引用 垃圾回收器的介绍 Serial收集器 是一个最基本、历史悠久的收集器，单线程，会暂停其它所有线程，直到垃圾回收完成（Stop the World!） 对于运行在Client下的虚拟机来说是很好的选择，简单而高效，没有线程交互产生的开销。 ParNew收集器 是Serial的多线程版本，大部分实现代码是一样的。 以上两种新生代收集器是唯一能够和CMS配合使用的收集器均使用复制算法。 Serial Old(MSC)收集器 Serial的老年代版收集器，使用标记-整理算法。 可以搭配Parallel Scavenge使用，或者作为CMS失败的后备方案 Parallel Old 收集器 Parallel的老年代版收集器，使用标记-整理算法。 注重CPU资源敏感和吞吐量的场合可以考虑Parallel Old 结合Parallel Scavenge。 Parallel Scavenge收集器（吞吐量优先） 是一个新生代收集器，主要关注点在吞吐量（既运行代码时间/（运行代码时间+垃圾收集时间）） 例如：虚拟机总运行100分钟，垃圾回收需要花费10分钟，那么吞吐量就是90%适合不需要交互的后台任务与ParNew的区别在于它可以使用GC自适应的调节策略，通过输入参数 -XX:UseAdaptiveSizePolicy 虚拟机会根据当前系统运行的情况收集性能监控，自动调节新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等参数。 CMS（Concurrent Mark Sweep）收集器 是以最短回收时间为目标的老年代收集器。 算法使用标记-清除算法，会产生内存碎片。 回收分为几个过程： 初始标记(标记GC Roots 能直接关联的对象)。 并发标记(进行GC Roots Tracing)。 重新标记(修正并发标记期间因用户程序操作而产生变动的那部分对象的标记记录)。 并发清除。 注：初始标记和重新标记会Stop the World，并发标记和并发清除不会停顿。 缺点： 对CPU资源敏感，吞吐量不高。 无法处理‘浮动垃圾’，可能出现‘Concurrent Mode Failure’,从而导致另一次的Full GC产生。 使用标记-清除算法会产生大量内存碎片。 G1(Garbage-First)收集器 相对于之前几个收集器，有很大的区别 不仅仅对于新生代或者老年代一个对象，而是把内存划分为Region,可以单独管理内存。 全局使用标记-整理，局部(Region之间)使用复制。 清理可预测性，通过跟踪每个Region内垃圾堆积的经验价值，在后台构建一个列表，每次垃圾回收，清理价值高的内存，以提高清理效率。 运作步骤： 初始标记(标记GC Roots 能直接关联的对象)。 并发标记(进行GC Roots Tracing)。 最终标记(修正并发标记期间因用户程序操作而产生变动的那部分对象的标记记录)。 筛选回收(对回收对象进行排序，在有限的条件下尽可能回收更多的内存对象)内存分配与回收策略 内存分配 对象优先在Eden分配 当Eden无法存放对象的时候，会触发Minor GC,发生GC的时候，如果存活的对象在Survivor中没有空间进行存储，超出的部分会直接通过担保机制进入老年代。 大对象直接进入老年代 大对象指的是需要连续空间的对象，如长字符串、byte[]数组等。 长期存活的对象将进入老年代 默认老年代的年龄是15，但是，有些对象也不必到15就能进入老年代。如果在Survivor中相同年龄的对象大于总空间的一半，那么大于这个年龄的所有对象将进入老年代。 类加载机制]]></content>
  </entry>
</search>
