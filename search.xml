<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java虚拟机]]></title>
    <url>%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[运行时数据区域 程序计数器（Program Counter Register）线程私有当前线程的执行指令的指向（虚拟机字节码指令的地址） Java虚拟机栈（VM Stack）线程私有每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等，局部变量表存放编译器可知的各种基本数据类型、对象引用、代表对象的句柄或其它与此对象相关的位置、returnAddress类型。其中double、long会占用两个局部变量的空间（Slot）。 有关这个区域的两种异常状况 1. StackOverflowError这个错误指的是栈的层数超出了虚拟机允许的层数 示例代码： @Test public void testStackOverflowError() { testStackOverflowError(); } 2. OotOfMemoryError这个错误指的是扩展内容超出了虚拟机分配的内存，无法请求得到 示例代码： @Test public void testOutOfMemoryError() { while(true) { new ArrayList&lt;String&gt;(1000000000); } } 本地方法栈（Native Method Stack）线程私有本地方法栈和虚拟机栈的作用差不多，服务对象是本地方法，而虚拟机栈是服务Java方法。其它方面和虚拟机栈差不多。 Sun Hot Spot 把两者合为一体。 Java堆（Heap）（GC堆）线程共享Java堆是线程共享的内存，在虚拟机启动的时候创建，唯一目的是存放对象实例。几乎所有的对象都是在Java堆上进行分配。 注：栈上分配、标量替换优化技术使得堆上分配技术变得不那么绝对。 Java堆可细分为新生代和老年代。新生代又可划分出Eden、From Survivor、To Survivor。还可划分为多个线程私有的分配缓冲区（TLAB），目的是为了防止多线程并发请求分配同一段内存冲突的情况发生。Java堆是逻辑上连续的内存空间，物理上不一定会连续。 通过 -Xms 可以设置堆的初始大小通过 -Xmx 可以设置堆的最大大小当堆上没有足够内存空间分配给对象或者没有空间进行扩展的时候，会抛出OutOfMemoryError 方法区（Method Area）线程共享用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 HotSpot 把它划分为永久代，或者说用永久代来实现方法区 内存回收主要是常量池回收和类型卸载 运行时常量池属于方法区的一部分，存放编译器生成的各种符号引用和字面量。 常量不一定只在编译器时产生，如String.intern()可以在运行时动态产生常量。 附加知识点直接内存不是虚拟机运行时区域的一部分，但是有一些关系，这里也来扯一下。通过使用Native函数直接分配堆外内存。本机直接内存不会受Java堆的限制，但会受本机内存的限制如RAM、Swap以及分页文件。 优点：可以显著提升性能，避免在Java堆和Native堆来回复制数据。]]></content>
  </entry>
</search>
