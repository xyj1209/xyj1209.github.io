<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java虚拟机]]></title>
    <url>%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[运行时数据区域 程序计数器（Program Counter Register）线程私有当前线程的执行指令的指向（虚拟机字节码指令的地址） Java虚拟机栈（VM Stack）线程私有每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等，局部变量表存放编译器可知的各种基本数据类型、对象引用、代表对象的句柄或其它与此对象相关的位置、returnAddress类型。其中double、long会占用两个局部变量的空间（Slot）。 有关这个区域的两种异常状况 1. StackOverflowError这个错误指的是栈的层数超出了虚拟机允许的层数 示例代码： @Test public void testStackOverflowError() { testStackOverflowError(); } 2. OotOfMemoryError这个错误指的是扩展内容超出了虚拟机分配的内存，无法请求得到 示例代码： @Test public void testOutOfMemoryError() { while(true) { new ArrayList&lt;String&gt;(1000000000); } } 本地方法栈（Native Method Stack）线程私有本地方法栈和虚拟机栈的作用差不多，服务对象是本地方法，而虚拟机栈是服务Java方法。其它方面和虚拟机栈差不多。 Sun Hot Spot 把两者合为一体。 Java堆（Heap）（GC堆）线程共享Java堆是线程共享的内存，在虚拟机启动的时候创建，唯一目的是存放对象实例。几乎所有的对象都是在Java堆上进行分配。 注：栈上分配、标量替换优化技术使得堆上分配技术变得不那么绝对。 Java堆可细分为新生代和老年代。新生代又可划分出Eden、From Survivor、To Survivor。还可划分为多个线程私有的分配缓冲区（TLAB），目的是为了防止多线程并发请求分配同一段内存冲突的情况发生。Java堆是逻辑上连续的内存空间，物理上不一定会连续。 通过 -Xms 可以设置堆的初始大小通过 -Xmx 可以设置堆的最大大小当堆上没有足够内存空间分配给对象或者没有空间进行扩展的时候，会抛出OutOfMemoryError 方法区（Method Area）线程共享用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 HotSpot 把它划分为永久代，或者说用永久代来实现方法区 内存回收主要是常量池回收和类型卸载 运行时常量池属于方法区的一部分，存放编译器生成的各种符号引用和字面量。 常量不一定只在编译器时产生，如String.intern()可以在运行时动态产生常量。 附加知识点直接内存不是虚拟机运行时区域的一部分，但是有一些关系，这里也来扯一下。通过使用Native函数直接分配堆外内存。本机直接内存不会受Java堆的限制，但会受本机内存的限制如RAM、Swap以及分页文件。 优点：可以显著提升性能，避免在Java堆和Native堆来回复制数据。 垃圾收集器与内存分配策略 垃圾回收算法 简略介绍几种垃圾回收算法 标记-清除算法标记-清除算法指的是对需要进行回收的内存段进行标记，再进行清除。 缺点： 空间问题：会产生大量不连续的碎片化的内存。 时间问题：标记和清除的效率都不高。 标记-整理算法标记-整理算法相对于标记-清除算法的改进在于回收内存后剩余的存活对象是连续的，空间效率变高了。 主要实现是让存活的对象向一端靠拢，再清除另一端被标记的内存对象。 以上两种算法多用于老年代的内存回收，由老年代内存对象大部分不被清理的特征决定了。 复制算法复制算法多用于新生代，把内存划分为Eden(80%)、From Survivor(10%)、To Survivor(10%),回收的过程是把Eden和一个Survivor区的存活对象复制到另一个Survivor,所以浪费的内存空间有10%。 复制算法用于新生代,由98%（不绝对）的新生代对象都会被回收的特征决定的。由于不能保证每次回收剩余的内存对象会少于10%,所以需要分配担保。所有超出10%的对象都会直接进入老年代。 判断对象是否存活的算法引用计数算法引用计数算法是给对象添加一个引用计数器，有引用，计数器加一，引用失效，计数器减一。引用计数器算法的效率很高，也很简单。但是，虚拟机并不采用这种方法。由以下代码可以说明： public class Main { public Object instance=null; public static void main(String[] args) { Main m1=new Main();//m1:0+1 Main m2=new Main(); m1.instance=m2;//m1:1+1 m2.instance=m1; m1=null;//m1:2-1 m2=null; System.gc(); } } 可达性分析算法可达性分析算法是判断对象到GC Roots有没有引用链，没有就被回收。 GC Roots： 虚拟机栈（栈帧的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI(即一般说的Native方法)引用的对象。 引用分类 强引用 软引用 弱引用 虚引用 垃圾回收器的介绍//TODO]]></content>
  </entry>
</search>
