<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><hr><h3 id="程序计数器（Program-Counter-Register）线程私有"><a href="#程序计数器（Program-Counter-Register）线程私有" class="headerlink" title="程序计数器（Program Counter Register）线程私有"></a>程序计数器（Program Counter Register）线程私有</h3><p>当前线程的执行指令的指向（虚拟机字节码指令的地址） </p><h3 id="Java虚拟机栈（VM-Stack）线程私有"><a href="#Java虚拟机栈（VM-Stack）线程私有" class="headerlink" title="Java虚拟机栈（VM Stack）线程私有"></a>Java虚拟机栈（VM Stack）线程私有</h3><p>每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等，局部变量表存放编译器可知的各种基本数据类型、对象引用、代表对象的句柄或其它与此对象相关的位置、returnAddress类型。其中double、long会占用两个局部变量的空间（Slot）。  </p><blockquote><p>有关这个区域的两种异常状况</p></blockquote><h4 id="1-StackOverflowError"><a href="#1-StackOverflowError" class="headerlink" title="1. StackOverflowError"></a>1. StackOverflowError</h4><p>这个错误指的是栈的层数超出了虚拟机允许的层数  </p><blockquote><p>示例代码：</p></blockquote><pre><code>@Test public void testStackOverflowError() {      testStackOverflowError();  }</code></pre><h4 id="2-OotOfMemoryError"><a href="#2-OotOfMemoryError" class="headerlink" title="2. OotOfMemoryError"></a>2. OotOfMemoryError</h4><p>这个错误指的是扩展内容超出了虚拟机分配的内存，无法请求得到  </p><blockquote><p>示例代码：</p></blockquote><pre><code>@Test  public void testOutOfMemoryError() {      while(true) {          new ArrayList&lt;String&gt;(1000000000);      }  }</code></pre><h3 id="本地方法栈（Native-Method-Stack）线程私有"><a href="#本地方法栈（Native-Method-Stack）线程私有" class="headerlink" title="本地方法栈（Native Method Stack）线程私有"></a>本地方法栈（Native Method Stack）线程私有</h3><p>本地方法栈和虚拟机栈的作用差不多，服务对象是本地方法，而虚拟机栈是服务Java方法。其它方面和虚拟机栈差不多。</p><blockquote><p>Sun Hot Spot 把两者合为一体。</p></blockquote><h3 id="Java堆（Heap）（GC堆）线程共享"><a href="#Java堆（Heap）（GC堆）线程共享" class="headerlink" title="Java堆（Heap）（GC堆）线程共享"></a>Java堆（Heap）（GC堆）线程共享</h3><p>Java堆是线程共享的内存，在虚拟机启动的时候创建，唯一目的是存放对象实例。几乎所有的对象都是在Java堆上进行分配。</p><blockquote><p>注：栈上分配、标量替换优化技术使得堆上分配技术变得不那么绝对。</p></blockquote><p>Java堆可细分为<strong>新生代</strong>和<strong>老年代</strong>。<br>新生代又可划分出<strong>Eden、From Survivor、To Survivor</strong>。<br>还可划分为<strong>多个线程私有的分配缓冲区（TLAB）</strong>，目的是为了防止多线程并发请求分配同一段内存冲突的情况发生。<br>Java堆是逻辑上连续的内存空间，物理上不一定会连续。</p><blockquote><p>通过 <strong>-Xms</strong> 可以设置堆的初始大小<br>通过 <strong>-Xmx</strong> 可以设置堆的最大大小<br>当堆上没有足够内存空间分配给对象或者没有空间进行扩展的时候，会抛出<strong>OutOfMemoryError</strong></p></blockquote><h3 id="方法区（Method-Area）线程共享"><a href="#方法区（Method-Area）线程共享" class="headerlink" title="方法区（Method Area）线程共享"></a>方法区（Method Area）线程共享</h3><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><blockquote><p>HotSpot 把它划分为永久代，或者说用永久代来实现方法区</p></blockquote><blockquote><p>内存回收主要是常量池回收和类型卸载</p></blockquote><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>属于方法区的一部分，存放编译器生成的各种符号引用和字面量。</p><blockquote><p>常量不一定只在编译器时产生，如String.intern()可以在运行时动态产生常量。</p></blockquote><h3 id="附加知识点"><a href="#附加知识点" class="headerlink" title="附加知识点"></a>附加知识点</h3><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>不是虚拟机运行时区域的一部分，但是有一些关系，这里也来扯一下。通过使用Native函数直接分配堆外内存。本机直接内存不会受Java堆的限制，但会受本机内存的限制如RAM、Swap以及分页文件。</p><blockquote><p>优点：可以显著提升性能，避免在Java堆和Native堆来回复制数据。</p></blockquote><hr><h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><hr><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><blockquote><p>简略介绍几种垃圾回收算法</p></blockquote><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记-清除算法指的是对需要进行回收的内存段进行标记，再进行清除。</p><blockquote><p>缺点：</p><ol><li>空间问题：会产生大量不连续的碎片化的内存。</li><li>时间问题：标记和清除的效率都不高。</li></ol></blockquote><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-整理算法相对于标记-清除算法的改进在于回收内存后剩余的存活对象是连续的，空间效率变高了。</p><blockquote><p>主要实现是让存活的对象向一端靠拢，再清除另一端被标记的内存对象。</p></blockquote><p><strong><em>以上两种算法多用于老年代的内存回收，由老年代内存对象大部分不被清理的特征决定了。</em></strong></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法多用于新生代，把内存划分为Eden(80%)、From Survivor(10%)、To Survivor(10%),回收的过程是把Eden和一个Survivor区的存活对象复制到另一个Survivor,所以浪费的内存空间有10%。</p><blockquote><p>复制算法用于新生代,由98%（不绝对）的新生代对象都会被回收的特征决定的。<br>由于不能保证每次回收剩余的内存对象会少于10%,所以需要分配担保。所有超出10%的对象都会直接进入老年代。</p></blockquote><h3 id="判断对象是否存活的算法"><a href="#判断对象是否存活的算法" class="headerlink" title="判断对象是否存活的算法"></a>判断对象是否存活的算法</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法是给对象添加一个引用计数器，有引用，计数器加一，引用失效，计数器减一。<br>引用计数器算法的效率很高，也很简单。但是，虚拟机并不采用这种方法。<br>由以下代码可以说明：</p><pre><code>public class Main {    public Object instance=null;    public static void main(String[] args) {        Main m1=new Main();//m1:0+1        Main m2=new Main();        m1.instance=m2;//m1:1+1        m2.instance=m1;        m1=null;//m1:2-1        m2=null;        System.gc();    }}</code></pre><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析算法是判断对象到GC Roots有没有引用链，没有就被回收。</p><blockquote><p>GC Roots：</p><ol><li>虚拟机栈（栈帧的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象。</li></ol></blockquote><blockquote><p>引用分类</p><ol><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li></ol></blockquote><h3 id="垃圾回收器的介绍"><a href="#垃圾回收器的介绍" class="headerlink" title="垃圾回收器的介绍"></a>垃圾回收器的介绍</h3><p>//TODO</p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
