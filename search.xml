<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java虚拟机]]></title>
    <url>%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[运行时数据区域 程序计数器（Program Counter Register）线程私有当前线程的执行指令的指向（虚拟机字节码指令的地址） Java虚拟机栈（VM Stack）线程私有每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等，局部变量表存放编译器可知的各种基本数据类型、对象引用、代表对象的句柄或其它与此对象相关的位置、returnAddress类型。其中double、long会占用两个局部变量的空间（Slot）。 有关这个区域的两种异常状况 1. StackOverflowError这个错误指的是栈的层数超出了虚拟机允许的层数 示例代码： @Test public void testStackOverflowError() { testStackOverflowError(); } 2. OotOfMemoryError这个错误指的是扩展内容超出了虚拟机分配的内存，无法请求得到 示例代码： @Test public void testOutOfMemoryError() { while(true) { new ArrayList&lt;String&gt;(1000000000); } } 本地方法栈（Native Method Stack）线程私有本地方法栈和虚拟机栈的作用差不多，服务对象是本地方法，而虚拟机栈是服务Java方法。其它方面和虚拟机栈差不多。 Sun Hot Spot 把两者合为一体。 Java堆（Heap）（GC堆）线程共享Java堆是线程共享的内存，在虚拟机启动的时候创建，唯一目的是存放对象实例。几乎所有的对象都是在Java堆上进行分配。 注：栈上分配、标量替换优化技术使得堆上分配技术变得不那么绝对。 Java堆可细分为新生代和老年代。新生代又可划分出Eden、From Survivor、To Survivor。还可划分为多个线程私有的分配缓冲区（TLAB），目的是为了防止多线程并发请求分配同一段内存冲突的情况发生。Java堆是逻辑上连续的内存空间，物理上不一定会连续。 通过 -Xms 可以设置堆的初始大小通过 -Xmx 可以设置堆的最大大小当堆上没有足够内存空间分配给对象或者没有空间进行拓展的时候，会抛出OutOfMemoryError]]></content>
  </entry>
</search>
